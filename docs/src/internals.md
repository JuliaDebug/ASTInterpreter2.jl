# Internals

The process of executing code in the interpreter is to prepare a `frame` and then
evaluate these statements one-by-one, branching via the `goto` statements as appropriate.
Using the `summer` example described in [Lowered representation](@ref),
let's build a frame:

```julia
julia> frame = ASTInterpreter2.enter_call(summer, A)
JuliaStackFrame(ASTInterpreter2.JuliaFrameCode(summer(A::AbstractArray{T,N} where N) where T in Main at REPL[1]:2, CodeInfo(
1 ─       s = ($(QuoteNode(zero)))($(Expr(:static_parameter, 1)))
│   %2  = A
│         #temp# = ($(QuoteNode(iterate)))(%2)
│   %4  = ($(QuoteNode(===)))(#temp#, nothing)
│   %5  = ($(QuoteNode(not_int)))(%4)
└──       goto #4 if not %5
2 ┄ %7  = #temp#
│         a = ($(QuoteNode(getfield)))(%7, 1)
│   %9  = ($(QuoteNode(getfield)))(%7, 2)
│         s = ($(QuoteNode(+)))(s, a)
│         #temp# = ($(QuoteNode(iterate)))(%2, %9)
│   %12 = ($(QuoteNode(===)))(#temp#, nothing)
│   %13 = ($(QuoteNode(not_int)))(%12)
└──       goto #4 if not %13
3 ─       goto #2
4 ┄       return s
), Core.TypeMapEntry[#undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef], BitSet([2, 4, 5, 7, 9, 12, 13]), false, false, true), Union{Nothing, Some{Any}}[Some(summer), Some([1, 2, 5]), nothing, nothing, nothing], Any[#undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef], Any[Int64], Int64[], Base.RefValue{Any}(nothing), Base.RefValue{ASTInterpreter2.JuliaProgramCounter}(JuliaProgramCounter(1)), Dict{Symbol,Int64}(), Any[])
```

This is a [`ASTInterpreter2.JuliaStackFrame`](@ref). The `CodeInfo` is the most prominent part of this display,
and extractable as `code = frame.code.code`. (It's a slightly modified form of one returned by `@code_lowered`,
in that it has been processed by [`ASTInterpreter2.optimize!`](@ref) to speed up run-time execution.)

Much of the rest of the `frame` holds values needed for or generated by execution.
The input arguments are in `locals`:

```julia
julia> frame.locals
5-element Array{Union{Nothing, Some{Any}},1}:
 Some(summer)
 Some([1, 2, 5])
 nothing
 nothing
 nothing
```

These correspond to the `code.slotnames`; the first is the `#self#` argument and the second
is the input array. The remaining local variables (e.g., `s` and `a`), have not yet been assigned---we've
only built the frame, but we haven't yet begun to execute it.
The static parameter, `T`, is stored in `frame.sparams`:

```julia
julia> frame.sparams
1-element Array{Any,1}:
 Int64
```

The `Expr(:static_parameter, 1)` statement refers to this value.

The other main storage is for the generated SSA values:

```julia
julia> frame.ssavalues
16-element Array{Any,1}:
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
```

Since we haven't executed any statements yet, these are all undefined.

The other main entity is the so-called [program counter](https://en.wikipedia.org/wiki/Program_counter),
which just indicates the next statement to be executed:

```julia
julia> frame.pc[]
JuliaProgramCounter(1)
```

This is stored as a `Ref` so that it can be updated as execution progresses.

Let's try executing the first statement. So that we can recurse into calls (e.g., `iterate`, `+`, etc.,),
we'll create a [stack](https://en.wikipedia.org/wiki/Call_stack) of frames and then run the first statement:

```julia
julia> stack = ASTInterpreter2.JuliaStackFrame[]
0-element Array{JuliaStackFrame,1}

julia> ASTInterpreter2.step_expr!(stack, frame)
JuliaProgramCounter(2)
```

This indicates that it ran statement 1 and is prepared to run statement 2.
(It's worth noting that the first line included a `call` to `zero`, so behind the scenes
ASTInterpreter2 pushed this frame onto `stack`, created a new frame for `zero`,
executed all the statements, and then popped the stack.)
Since the first statement is an assignment of a local variable, let's check the
locals again:

```julia
julia> frame.locals
5-element Array{Union{Nothing, Some{Any}},1}:
 Some(summer)
 Some([1, 2, 5])
 Some(0)
 nothing
 nothing
```

You can see that the entry corresponding to `s` has been initialized.

The next statement just retrieves one of the slots (the input argument `A`) and stores
it in an SSA value:

```julia
julia> ASTInterpreter2.step_expr!(stack, frame)
JuliaProgramCounter(3)

julia> frame.ssavalues
16-element Array{Any,1}:
 #undef
 #undef
    [1, 2, 5]
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
```

(The indexing is shifted by one, so index 3 corresponds to %2.) Since the first statement
didn't result in an SSAValue that gets used later, it remains undefined.

One can easily continue this until execution completes, which is indicated when `step_expr!`
returns `nothing`.
