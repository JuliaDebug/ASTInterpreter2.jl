# This file generates builtins.jl.

# Look up the expected number of arguments in Core.Compiler.tfunc data
function generate_fcall(f, table, id)
    if id !== nothing
        minarg, maxarg, tfunc = table[id]
    else
        minarg = 0
        maxarg = typemax(Int)
    end
    # The tfunc tables are wrong for fptoui and fptosi
    if f == "Base.fptoui" || f == "Base.fptosi"
        minarg = 2
    end
    # Generate a separate call for each number of arguments
    if maxarg < typemax(Int)
        wrapper = minarg == maxarg ? "" : "if nargs == "
        for nargs = minarg:maxarg
            if minarg < maxarg
                wrapper *= "$nargs\n            "
            end
            argcall = ""
            for i = 1:nargs
                argcall *= "@eval_rhs(true, frame, args[$(i+1)])"
                if i < nargs
                    argcall *= ", "
                end
            end
            wrapper *= "return Some{Any}($f($argcall))"
            if nargs < maxarg
                wrapper *= "\n        elseif nargs == "
            end
        end
        if minarg < maxarg
            wrapper *= "\n        end"
        end
        return wrapper
    end
    # A built-in with arbitrary or unknown number of arguments.
    # This will (unfortunately) use dynamic dispatch.
    return "return Some{Any}($f(getargs(args, frame)...))"
end

# `io` is for the generated source file
# `intrinsicsfile` is the path to Julia's `src/intrinsics.h` file
function generate_builtins(io::IO, intrinsicsfile)
    pat = r"(ADD_I|ALIAS)\((\w*),"
    print(io,
"""
# This file is generated by `generate_builtins.jl`. Do not edit by hand.

function getargs(args, frame)
    nargs = length(args)-1  # skip f
    callargs = resize!(frame.callargs, nargs)
    for i = 1:nargs
        callargs[i] = @eval_rhs(true, frame, args[i+1])
    end
    return callargs
end

function maybe_evaluate_builtin(frame, call_expr)
    # Builtin calls can't be handled by lowering, so we have to evaluate these directly.
    # We do this based on the call expression rather than using `to_function` because
    # both `to_function` and `isa(f, Core.Builtin)` are quite slow, as is the (dynamic)
    # evaluation. By having each call appearing statically in the "switch" block below,
    # each gets call-site optimized.

    args = call_expr.args
    nargs = length(args) - 1
    fex = args[1]
    if isa(fex, QuoteNode)
        f = fex.value
    else
        f = @eval_rhs(true, frame, fex)
    end
    # Builtins and intrinsics have empty method tables. We can circumvent
    # a long "switch" check by looking for this.
    mt = typeof(f).name.mt
    if isa(mt, Core.MethodTable)
        isempty(mt) || return call_expr
    end
    # Builtins
""")
    firstcall = true
    for ft in subtypes(Core.Builtin)
        ft === Core.IntrinsicFunction && continue
        ft === getfield(Core, Symbol("#kw##invoke")) && continue  # handle this one later
        head = firstcall ? "if" : "elseif"
        firstcall = false
        f = ft.instance
        # Tuple is common, especially for returned values from calls. It's worth avoiding
        # dynamic dispatch through a call to `ntuple`.
        if f === tuple
            print(io,
"""
    $head f === $f
        return Some{Any}(ntuple(i->@eval_rhs(true, frame, args[i+1]), length(args)-1))
""")
            continue
        end
        id = findfirst(isequal(f), Core.Compiler.T_FFUNC_KEY)
        fcall = generate_fcall(f, Core.Compiler.T_FFUNC_VAL, id)
        print(io,
"""
    $head f === $f
        $fcall
""")
        firstcall = false
    end
    print(io,
"""
    # Intrinsics
""")
    for line in readlines(intrinsicsfile)
        m = match(pat, line)
        m === nothing && continue
        fname = m.captures[2]
        fsym = Symbol(fname)
        isdefined(Base, fsym) || (println("skipping ", fname); continue)
        f = getfield(Base, fsym)
        f isa Core.IntrinsicFunction || error("not an intrinsic")
        id = reinterpret(Int32, f) + 1
        f = isdefined(Base, fsym) ? "Base.$fsym" :
            isdefined(Core, fsym) ? "Core.$fsym" : error("whoops on $f")
        fcall = generate_fcall(f, Core.Compiler.T_IFUNC, id)
        print(io,
"""
    elseif f === $f
        $fcall
""")
    end
    print(io,
"""
    end
    if isa(f, getfield(Core, Symbol("#kw##invoke")))
        return Some{Any}(getfield(Core, Symbol("#kw##invoke"))(getargs(args, frame)...))
    end
    return call_expr
end
""")
end
