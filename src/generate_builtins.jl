module Unsullied end  # for testing for names exported by Base

# Look up the expected number of arguments in Core.Compiler.tfunc data
function generate_argcall(table, id)
    if id !== nothing
        minarg, maxarg, tfunc = table[id]
        nargs = minarg == maxarg ? minarg : -1
    else
        nargs = -1
    end
    if nargs >= 0
        argcall = ""
        for i = 1:nargs
            argcall *= "@eval_rhs(stack, frame, args[$(i+1)], pc)"
            if i < nargs
                argcall *= ", "
            end
        end
    else
        argcall = "getargs(args, stack, frame, pc)..."
    end
    return argcall
end

# `io` is for the generated source file
# `intrinsicsfile` is the path to Julia's `src/intrinsics.h` file
function generate_builtins(io::IO, intrinsicsfile)
    pat = r"(ADD_I|ALIAS)\((\w*),"
    print(io,
"""
# This file is generated by `generate_builtins.jl`. Do not edit by hand.

getargs(args, stack, frame, pc) = Any[@eval_rhs(stack, frame, a, pc) for a in Iterators.drop(args, 1)]

function maybe_evaluate_builtin(stack, frame, call_expr, pc)
    # Builtin calls can't be handled by lowering, so we have to evaluate these directly.
    # We do this based on the call expression rather than using `to_function` because
    # both `to_function` and `isa(f, Core.Builtin)` are quite slow, as is the (dynamic)
    # evaluation. By having each call appearing statically in the "switch" block below,
    # each gets call-site optimized.

    args = call_expr.args
    fex = args[1]
    if isa(fex, GlobalRef)
        mod = fex.mod
        inBase = mod == Base || mod == Core
        while !inBase && mod != Main
            mod = parentmodule(mod)
            inBase = mod == Base || mod == Core
        end
        if inBase
            name = fex.name
            if fex.mod == Core.Compiler
                if name == :getproperty
                    name = :getfield
                elseif name == :setproperty!
                    name = :setfield!
                end
            end
            # Builtins
""")
    firstcall = true
    for ft in subtypes(Core.Builtin)
        ft === Core.IntrinsicFunction && continue
        head = firstcall ? "if" : "elseif"
        f = ft.instance
        if f == tuple
            print(io,
"""
            $head name == :tuple
                return Some{Any}(ntuple(i->@eval_rhs(stack, frame, args[i+1], pc), length(args)-1))
""")
            continue
        end
        id = findfirst(isequal(f), Core.Compiler.T_FFUNC_KEY)
        argcall = generate_argcall(Core.Compiler.T_FFUNC_VAL, id)
        fname = String(ft.name.name)[2:end]
        occursin('#', fname) && continue # #kw##invoke
        modscope = "Core."
        if fname[1] âˆˆ ('<', '=')
            fname = '(' * fname * ')'
            modscope = ""
        elseif isdefined(Unsullied, Symbol(fname))
            modscope = ""
        end
        print(io,
"""
            $head name == :$fname
                return Some{Any}($(modscope)$(fname)($argcall))
""")
        firstcall = false
    end
    print(io,
"""
            # Intrinsics
""")
    for line in readlines(intrinsicsfile)
        m = match(pat, line)
        m === nothing && continue
        fname = m.captures[2]
        fsym = Symbol(fname)
        isdefined(Base, fsym) || (println("skipping ", fname); continue)
        f = getfield(Base, fsym)
        f isa Core.IntrinsicFunction || error("not an intrinsic")
        id = reinterpret(Int32, f) + 1
        argcall = generate_argcall(Core.Compiler.T_IFUNC, id)
        print(io,
"""
            elseif name == :$fname
                return Some{Any}(Base.$fname($argcall))
""")
    end
    print(io,
"""
            end
        end
    end
    return call_expr
end
""")
end
